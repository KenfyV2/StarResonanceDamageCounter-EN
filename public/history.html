<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>BP: Star Resonance Historical Combat Data</title>
        <script src="echarts.min.js"></script>
        <link rel="stylesheet" type="text/css" href="css/style.css" />
    </head>

    <body>
        <!-- ÊäÄËÉΩÁªüËÆ°ÂºπÁ™ó -->
        <div id="skillModal" class="skill-modal">
            <div class="skill-modal-content" style="max-width: 70vw; max-height: 95vh; margin: 2% auto">
                <div class="skill-modal-header" style="padding: 0px 25px">
                    <h2 class="skill-modal-title">
                        <i class="icon">üìä</i>
                        <span id="skillUserName">Skill Participation Statistics</span>
                    </h2>
                    <span class="skill-modal-close" onclick="closeSkillModal()">&times;</span>
                </div>
                <div class="skill-modal-body" style="max-height: calc(95vh - 110px)">
                    <div class="skill-user-info">
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">User ID</div>
                            <div class="skill-user-info-value" id="skillUserId">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">Character Nickname</div>
                            <div class="skill-user-info-value" id="skillUserNickname">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">Occupation</div>
                            <div class="skill-user-info-value" id="skillUserProfession">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">Combat Rating</div>
                            <div class="skill-user-info-value" id="fightPoint">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">Max HP</div>
                            <div class="skill-user-info-value" id="maxHp">-</div>
                        </div>
                        <div class="skill-user-info-item">
                            <div class="skill-user-info-label">Number of Skills</div>
                            <div class="skill-user-info-value" id="skillCount">-</div>
                        </div>
                    </div>

                    <div class="skill-view-toggle">
                        <div class="skill-view-toggle-buttons">
                            <button class="skill-view-btn active" data-view="damage" onclick="switchSkillView('damage')">Damage Skill</button>
                            <button class="skill-view-btn" data-view="healing" onclick="switchSkillView('healing')">Healing Skill</button>
                        </div>
                    </div>

                    <div class="skill-stats-container">
                        <div class="skill-chart-container" id="skillDamageChart"></div>
                        <div class="skill-chart-container" id="skillCritChart"></div>
                    </div>

                    <div class="skill-table-container">
                        <table class="skill-table" id="skillTable">
                            <thead>
                                <tr>
                                    <th>Skill Name</th>
                                    <th>Element</th>
                                    <th>Percentage</th>
                                    <th>Total value</th>
                                    <th>Number of timesÊ¨°Êï∞</th>
                                    <th>Critical Hit Rate</th>
                                    <th>Lucky Hit Rate</th>
                                    <th>Critical Hit Value</th>
                                    <th>Ordinary values</th>
                                </tr>
                            </thead>
                            <tbody id="skillTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div>
            <label for="chooseTime" style="margin-right: 10px; font-weight: bold">Time:</label>
            <select
                id="chooseTime"
                onchange="updateTimeStamp()"
                style="margin-right: 10px; padding: 8px 12px; font-size: 14px; border-radius: 5px; border: 1px solid #ddd; background-color: white"
            ></select>
            <label for="sortSelect" style="margin-right: 10px; font-weight: bold">Sorting method:</label>
            <select
                id="sortSelect"
                onchange="updateSortMode()"
                style="padding: 8px 12px; font-size: 14px; border-radius: 5px; border: 1px solid #ddd; background-color: white"
            >
                <option value="uid">Sort by UID (Ascending)</option>
                <option value="fightPoint">Sort by Rating (Descending)</option>
                <option value="takenDamage">Sort by Damage Taken (Descending)</option>
                <option value="damage">Sort by Total Damage (Descending order)</option>
                <option value="dps">Sort by Total DPS (Descending order)</option>
                <option value="realtimeDpsMax">Sort by Maximum Instantaneous DPS (Descending order)</option>
                <option value="healing">Sort by Total Healing (Descending)</option>
                <option value="hps">Sort by Total HPS (Descending)</option>
                <option value="realtimeHpsMax">Sort by Maximum Instantaneous HPS (Descending order)</option>
                <option value="hp_min">Sort by Remaining HP (Ascending order)</option>
            </select>
        </div>
        <!-- Êï∞ÊçÆÁªÑÊòæÁ§∫ÊéßÂà∂ -->
        <div class="data-group-controls">
            <button id="damageGroupBtn" class="data-group-button active" onclick="toggleDataGroup('damage')">‚öîÔ∏è Damage & DPS</button>
            <button id="healingGroupBtn" class="data-group-button" onclick="toggleDataGroup('healing')">‚ù§Ô∏è Healing & HPS</button>
            <button id="allGroupBtn" class="data-group-button" onclick="toggleDataGroup('all')">üìä All data</button>
            <button id="hideInactiveBtn" class="data-group-button" onclick="toggleHideInactiveUsers()">üëÄ Hide non-participants</button>
            <button class="data-group-button" onclick="openColumnSettings()">‚öôÔ∏è Table Settings</button>
            <button class="data-group-button" onclick="downloadFightLog()">üì• Download Combat Log</button>
        </div>
        <div class="table-container" style="max-height: calc(100vh - 140px)">
            <table id="damageTable">
                <thead>
                    <tr>
                        <th rowspan="2" title="ËßíËâ≤ÂîØ‰∏ÄÊ†áËØÜÁ¨¶">Character ID</th>
                        <th rowspan="2" title="ËßíËâ≤ÊòµÁß∞/Ëá™ÂÆö‰πâÊòµÁß∞">Character Nickname</th>
                        <th rowspan="2" title="ËßíËâ≤ËÅå‰∏ö">Occupation</th>
                        <th rowspan="2" title="ËßíËâ≤ËØÑÂàÜ">Rating</th>
                        <th rowspan="2" title="ËßíËâ≤Ë°ÄÈáè">HP</th>
                        <th rowspan="2" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÂèóÂà∞ÁöÑ‰º§ÂÆ≥">Damage Taken</th>
                        <th rowspan="2" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠Ê≠ª‰∫°Ê¨°Êï∞">Death</th>
                        <th rowspan="2" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊö¥Âáª‰º§ÂÆ≥Ê¨°Êï∞Âç†ÊÄª‰º§ÂÆ≥Ê¨°Êï∞ÁöÑÊØî‰æã">Critical Hit Rate</th>
                        <th rowspan="2" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÂπ∏Ëøê‰º§ÂÆ≥Ê¨°Êï∞Âç†ÊÄª‰º§ÂÆ≥Ê¨°Êï∞ÁöÑÊØî‰æã">Lucky Hit Rate</th>
                        <th class="damage-main-col" colspan="4">Damage</th>
                        <th class="damage-simple-col" style="display: none" colspan="1">Damage</th>
                        <th class="dps-col" colspan="3">DPS</th>
                        <th class="healing-main-col" colspan="4">Healing</th>
                        <th class="healing-simple-col" style="display: none" colspan="1">Healing</th>
                        <th class="hps-col" colspan="3">HPS</th>
                        <th rowspan="2">Operation</th>
                    </tr>
                    <tr>
                        <th class="damage-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÊÄª‰º§ÂÆ≥">Total Damage</th>
                            <th class="damage-detail-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÈùûÂπ∏ËøêÁöÑÊö¥Âáª‰º§ÂÆ≥">True Critical Hit</th>
                            <th class="damage-detail-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÈùûÊö¥ÂáªÁöÑÂπ∏Ëøê‰º§ÂÆ≥">True Luck</th>
                            <th class="damage-detail-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÊö¥ÂáªÁöÑÂπ∏Ëøê‰º§ÂÆ≥">Critical Hit Luck</th>
                            <th class="dps-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊúÄËøë‰∏ÄÁßíÈÄ†ÊàêÁöÑ‰º§ÂÆ≥">Instantaneous DPS</th>
                            <th class="dps-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊúÄÂ§ßÁû¨Êó∂DPS">Maximum instantaneous</th>
                            <th class="dps-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊÄªDPSÔºà‰ª•Á¨¨‰∏ÄÊ¨°ÊäÄËÉΩ‰∏éÊúÄÂêé‰∏ÄÊ¨°ÊäÄËÉΩ‰πãÈó¥ÁöÑÊó∂Èó¥‰Ωú‰∏∫ÊúâÊïàÊàòÊñóÊó∂Èó¥ËÆ°ÁÆóÔºâ">Total DPS</th>
                            <th class="healing-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÊÄªÊ≤ªÁñóÈáè">Overall Treatment</th>
                            <th class="healing-detail-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÈùûÂπ∏ËøêÁöÑÊö¥ÂáªÊ≤ªÁñóÈáè">True Critical Hit</th>
                            <th class="healing-detail-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÈùûÊö¥ÂáªÁöÑÂπ∏ËøêÊ≤ªÁñóÈáè">True Luck</th>
                            <th class="healing-detail-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÈÄ†ÊàêÁöÑÊö¥ÂáªÁöÑÂπ∏ËøêÊ≤ªÁñóÈáè">Critical Hit Luck</th>
                            <th class="hps-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊúÄËøë‰∏ÄÁßíÈÄ†ÊàêÁöÑ‰º§ÂÆ≥ÂíåÊ≤ªÁñóÈáè">Instantaneous HPS</th>
                            <th class="hps-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊúÄÂ§ßÁû¨Êó∂HPS">Maximum instantaneous</th>
                            <th class="hps-cols" title="ËßíËâ≤Âú®ÊàòÊñó‰∏≠ÁöÑÊÄªHPSÔºà‰ª•Á¨¨‰∏ÄÊ¨°ÊäÄËÉΩ‰∏éÊúÄÂêé‰∏ÄÊ¨°ÊäÄËÉΩ‰πãÈó¥ÁöÑÊó∂Èó¥‰Ωú‰∏∫ÊúâÊïàÊàòÊñóÊó∂Èó¥ËÆ°ÁÆóÔºâ">Total HPS</th>
                    </tr>
                </thead>
                <div class="no-data">üïó Please select the correct time to retrieve the data.</div>
                <tbody></tbody>
            </table>
        </div>

        <script>
            let historyTimeStamp = 0;
            let availableTimeStamps = [];
            let currentSortMode = 'uid'; // ÈªòËÆ§ÊåâUIDÊéíÂ∫è
            let userNicknames = JSON.parse(localStorage.getItem('userNicknames') || '{}');

            // Êï∞ÊçÆÁªÑÊòæÁ§∫ÊéßÂà∂Áõ∏ÂÖ≥ÂèòÈáè
            let currentDataGroup = 'damage';
            let lastVisiableUserArray = [];

            // ÈöêËóèÊú™ÂèÇÊàòËßíËâ≤Áõ∏ÂÖ≥ÂèòÈáè
            let hideInactiveUsers = false;

            // Êñ∞Â¢ûÊäÄËÉΩÂàÜÊûêÂäüËÉΩ
            let skillChart1 = null;
            let skillChart2 = null;
            let currentSkillUserId = 0;
            let currentSkillData = null;
            let currentSkillView = 'damage';
            const SKILL_VIEW_LABELS = {
                damage: 'Damage',
                healing: 'Healing',
            };
            let skillChartsResizeListenerRegistered = false;

            // Â§çÂà∂Áî®Êà∑Êï∞ÊçÆ
            function copyUserData(userId) {
                const user = getUserFromArray(userId);
                if (!user) {
                    console.error('No user data found');
                    return;
                }

                const hasValidName = user.name && user.name.trim() !== '';
                const nickname = userNicknames[userId] || (hasValidName ? user.name : '') || '';
                const copyText = `${nickname}#${userId} Damage:${user.total_damage.total} Healing:${user.total_healing.total} DPS:${user.total_dps.toFixed(2)} HPS:${user.total_hps.toFixed(2)}`;

                // Â§çÂà∂ÊòµÁß∞Âà∞Ââ™Ë¥¥Êùø
                navigator.clipboard
                    .writeText(copyText)
                    .then(() => {
                        // ÊòæÁ§∫Â§çÂà∂ÊàêÂäüÊèêÁ§∫
                        showCopySuccess();
                    })
                    .catch((err) => {
                        console.error('Copy failed:', err);
                        // ÈôçÁ∫ßÊñπÊ°àÔºö‰ΩøÁî®‰º†ÁªüÊñπÊ≥ïÂ§çÂà∂
                        try {
                            const textArea = document.createElement('textarea');
                            textArea.value = copyText;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            showCopySuccess();
                        } catch (e) {
                            console.error('The downgrade replication plan also failed:', e);
                        }
                    });
            }

            // ÊòæÁ§∫Â§çÂà∂ÊàêÂäüÊèêÁ§∫
            function showCopySuccess() {
                // ÂàõÂª∫‰∏¥Êó∂ÊèêÁ§∫ÂÖÉÁ¥†
                const toast = document.createElement('div');
                toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                z-index: 10000;
                font-size: 14px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                animation: slideIn 0.3s ease-out;
            `;
                toast.textContent = '‚úÖ User data has been copied.';
                document.body.appendChild(toast);

                // 3ÁßíÂêéÁßªÈô§ÊèêÁ§∫
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 3000);
            }

            // ÊòæÁ§∫ÊäÄËÉΩÂàÜÊûêÂºπÁ™ó
            async function showSkillAnalysis(userId) {
                currentSkillUserId = userId;
                currentSkillView = 'damage';
                currentSkillData = null;
                updateSkillViewButtons();
                updateSkillDisplay();
                const modal = document.getElementById('skillModal');
                modal.style.display = 'block';

                // Ëé∑ÂèñÊäÄËÉΩÊï∞ÊçÆ
                await fetchSkillData(userId);
            }

            // ÂÖ≥Èó≠ÊäÄËÉΩÂºπÁ™ó
            function closeSkillModal() {
                const modal = document.getElementById('skillModal');
                modal.style.display = 'none';
                currentSkillData = null;

                // ÈîÄÊØÅÂõæË°®ÂÆû‰æã
                if (skillChart1) {
                    skillChart1.dispose();
                    skillChart1 = null;
                }
                if (skillChart2) {
                    skillChart2.dispose();
                    skillChart2 = null;
                }
            }

            // Ëé∑ÂèñÊäÄËÉΩÊï∞ÊçÆ
            async function fetchSkillData(userId) {
                try {
                    const response = await fetch(`/api/history/${historyTimeStamp}/skill/${userId}`);
                    const data = await response.json();

                    if (data.code === 0) {
                        renderSkillData(data.data);
                    } else {
                        console.error('Failed to retrieve skill data:', data.msg);
                    }
                } catch (error) {
                    console.error('Failed to retrieve skill data:', error);
                }
            }

            // Ê∏≤ÊüìÊäÄËÉΩÊï∞ÊçÆ
            function renderSkillData(skillData) {
                const userInfo = getUserFromArray(skillData.uid);

                // Êõ¥Êñ∞Áî®Êà∑‰ø°ÊÅØ
                document.getElementById('skillUserId').textContent = skillData.uid;
                document.getElementById('skillUserName').textContent = `${skillData.name || `UID:${skillData.uid}`} - Skill Analysis`;
                document.getElementById('skillUserNickname').textContent = skillData.name;
                document.getElementById('skillUserProfession').textContent = userInfo ? userInfo.profession || 'Unknown' : 'Unknown';
                document.getElementById('fightPoint').textContent = userInfo ? userInfo.fightPoint || 'Unknown' : 'Unknown';
                document.getElementById('maxHp').textContent = skillData.attr ? skillData.attr.max_hp || 'Unknown' : 'Unknown';

                currentSkillData = skillData;

                updateSkillViewButtons();
                updateSkillDisplay();
            }

            function updateSkillDisplay() {
                const typeLabel = SKILL_VIEW_LABELS[currentSkillView] || 'Skill';

                const tableBody = document.getElementById('skillTableBody');
                const skillCountElement = document.getElementById('skillCount');

                if (!currentSkillData || !currentSkillData.skills) {
                    if (skillCountElement) {
                        skillCountElement.textContent = '0';
                    }
                    if (tableBody) {
                        tableBody.innerHTML = '';
                        const emptyRow = document.createElement('tr');
                        emptyRow.className = 'skill-empty-row';
                        const emptyCell = document.createElement('td');
                        emptyCell.colSpan = 10;
                        emptyCell.textContent = `Not available${typeLabel}Skill Data`;
                        emptyRow.appendChild(emptyCell);
                        tableBody.appendChild(emptyRow);
                    }
                    renderSkillCharts([], [], [], [], typeLabel);
                    return;
                }

                const skillsEntries = Object.entries(currentSkillData.skills || {});
                const totalSkillCount = skillsEntries.length;
                const filteredSkills = skillsEntries.filter(([, skill]) => {
                    const type = (skill.type || '').trim();
                    const isHealingSkill = type === SKILL_VIEW_LABELS.healing;
                    const isDamageSkill = type === SKILL_VIEW_LABELS.damage || type === '';
                    if (currentSkillView === 'healing') {
                        return isHealingSkill;
                    }
                    return isDamageSkill;
                });

                if (skillCountElement) {
                    skillCountElement.textContent = `${filteredSkills.length}/${totalSkillCount}`;
                }

                if (!tableBody) return;
                tableBody.innerHTML = '';

                if (filteredSkills.length === 0) {
                    const emptyRow = document.createElement('tr');
                    emptyRow.className = 'skill-empty-row';
                    const emptyCell = document.createElement('td');
                    emptyCell.colSpan = 10;
                    emptyCell.textContent = `Not available${typeLabel}Skill Data`;
                    emptyRow.appendChild(emptyCell);
                    tableBody.appendChild(emptyRow);
                    renderSkillCharts([], [], [], [], typeLabel);
                    return;
                }

                const sortedSkills = filteredSkills
                    .map(([skillId, skill]) => ({ skillId, skill }))
                    .sort((a, b) => Number(b.skill.totalDamage ?? 0) - Number(a.skill.totalDamage ?? 0));

                // ‰∏∫ÂõæË°®ÂáÜÂ§á‰∏âÁªÑÊï∞ÊçÆ
                const skillNames = []; // Áî®Êù•Â≠ò displayName
                const damages = [];
                const critRates = [];
                const luckyRates = [];
                const sortedSkillDamage = sortedSkills.reduce((sum, { skill }) => sum + Number(skill.totalDamage ?? 0), 0);

                // Ê∏≤ÊüìË°®Ê†º + Êî∂ÈõÜÂõæË°®Êï∞ÊçÆ
                sortedSkills.forEach(({ skillId, skill }) => {
                    const name = skill.displayName || skillId;
                    const damageBreakdown = skill.damageBreakdown || {};
                    const critDamage = Number(damageBreakdown.critical || 0) + Number(damageBreakdown.crit_lucky || 0);
                    const normalDamage = Number(damageBreakdown.normal || 0) + Number(damageBreakdown.lucky || 0);
                    //Âç†ÊØî
                    const percentage = sortedSkillDamage > 0 ? (Number(skill.totalDamage ?? 0) / sortedSkillDamage) * 100 : 0;

                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${name}</td>
                        <td>${skill.elementype || '-'}</td>
                        <td>${percentage.toFixed(2)}%</td>
                        <td>${Number(skill.totalDamage ?? 0).toLocaleString()}</td>
                        <td>${skill.totalCount ?? 0}</td>
                        <td class="skill-crit">${(Number(skill.critRate ?? 0) * 100).toFixed(2)}%</td>
                        <td class="skill-lucky">${(Number(skill.luckyRate ?? 0) * 100).toFixed(2)}%</td>
                        <td>${critDamage.toLocaleString()}</td>
                        <td>${normalDamage.toLocaleString()}</td>
                    `;
                    tableBody.appendChild(row);

                    // Êî∂ÈõÜÁªôÂõæË°®ÁöÑÊï∞ÊçÆ
                    skillNames.push(name);
                    damages.push(Number(skill.totalDamage ?? 0));
                    critRates.push(Number(skill.critRate ?? 0) * 100);
                    luckyRates.push(Number(skill.luckyRate ?? 0) * 100);
                });

                renderSkillCharts(skillNames, damages, critRates, luckyRates, typeLabel);
            }

            function updateSkillViewButtons() {
                document.querySelectorAll('.skill-view-btn').forEach((button) => {
                    const view = button.getAttribute('data-view');
                    if (view === currentSkillView) {
                        button.classList.add('active');
                        button.setAttribute('aria-pressed', 'true');
                    } else {
                        button.classList.remove('active');
                        button.setAttribute('aria-pressed', 'false');
                    }
                });
            }

            function switchSkillView(view) {
                if (!SKILL_VIEW_LABELS[view] || currentSkillView === view) {
                    return;
                }
                currentSkillView = view;
                updateSkillViewButtons();
                updateSkillDisplay();
            }

            function ensureSkillChartsResizeListener() {
                if (skillChartsResizeListenerRegistered) return;
                skillChartsResizeListenerRegistered = true;
                window.addEventListener('resize', () => {
                    if (skillChart1) skillChart1.resize();
                    if (skillChart2) skillChart2.resize();
                });
            }

            // Ê∏≤ÊüìÊäÄËÉΩÂõæË°®
            function renderSkillCharts(skillNames, damages, critRates, luckyRates, typeLabel) {
                const damageChartEl = document.getElementById('skillDamageChart');
                const critChartEl = document.getElementById('skillCritChart');

                if (!damageChartEl || !critChartEl) {
                    return;
                }

                if (skillChart1) {
                    skillChart1.dispose();
                    skillChart1 = null;
                }
                if (skillChart2) {
                    skillChart2.dispose();
                    skillChart2 = null;
                }

                skillChart1 = echarts.init(damageChartEl);
                skillChart2 = echarts.init(critChartEl);

                if (!Array.isArray(skillNames) || skillNames.length === 0) {
                    const emptyText = `Not available${typeLabel}Skill Data`;
                    const emptyGraphic = {
                        type: 'text',
                        left: 'center',
                        top: 'middle',
                        style: {
                            text: emptyText,
                            fill: '#94a3b8',
                            fontSize: 16,
                        },
                    };

                    skillChart1.setOption({
                        title: {
                            text: `${typeLabel}Skill Value Distribution`,
                            left: 'center',
                            textStyle: { color: '#e2e8f0' },
                        },
                        graphic: emptyGraphic,
                        series: [
                            {
                                name: `${typeLabel}Skill Values`,
                                type: 'pie',
                                data: [],
                            },
                        ],
                    });

                    skillChart2.setOption({
                        title: {
                            text: `${typeLabel}Skill Critical Hit Rate and Luck Trigger Rate`,
                            left: 'center',
                            textStyle: { color: '#e2e8f0' },
                        },
                        graphic: emptyGraphic,
                        xAxis: { show: false },
                        yAxis: { show: false },
                        series: [],
                    });

                    ensureSkillChartsResizeListener();
                    return;
                }

                const topNames = skillNames.slice(0, 5);
                const topDamages = damages.slice(0, 5);
                const topAllDamages = topDamages.reduce((a, b) => a + b, 0);
                const allDamages = damages.reduce((a, b) => a + b, 0);
                const otherDamages = Math.max(0, allDamages - topAllDamages);

                // ÊûÑÈÄ†Ââç 5 ÁöÑ dataÔºåÂπ∂‰∏îÈÉΩÊòæÁ§∫Ê†áÁ≠æ
                const pieData = topNames.map((name, idx) => ({
                    value: topDamages[idx],
                    name,
                    label: {
                        show: true, // ÊâìÂºÄËøô‰∏ÄÈ°πÁöÑÊ†áÁ≠æ
                        position: 'outside', // ÊîæÂà∞ÊâáÂå∫Â§ñ‰æß
                        formatter: '{b}\n{d}%', // ÊòæÁ§∫‚ÄúÂêçÁß∞ + ÁôæÂàÜÊØî‚Äù
                    },
                    labelLine: {
                        show: true, // ÊòæÁ§∫ÂºïÂØºÁ∫ø
                    },
                }));
                if (otherDamages > 0) {
                    pieData.push({
                        value: otherDamages,
                        name: 'Others',
                        label: {
                            show: true,
                            position: 'outside',
                            formatter: '{b}\n{d}%',
                        },
                        labelLine: {
                            show: true,
                        },
                    });
                }

                // ÊäÄËÉΩÊï∞ÂÄºÂàÜÂ∏ÉÂõæ
                const damageOption = {
                    title: {
                        text: `${typeLabel}Skill Value Distribution`,
                        left: 'center',
                        textStyle: { color: '#e2e8f0' },
                    },
                    tooltip: {
                        trigger: 'item',
                        formatter: '{b}: {c} ({d}%)',
                        backgroundColor: 'rgba(40, 40, 60, 0.9)',
                        borderColor: '#3498db',
                        textStyle: { color: '#ecf0f1' },
                    },
                    legend: {
                        orient: 'vertical',
                        right: 10,
                        top: 'center',
                        textStyle: { color: '#cbd5e0' },
                    },
                    series: [
                        {
                            name: `${typeLabel}Skill Values`,
                            type: 'pie',
                            radius: ['40%', '70%'],
                            avoidLabelOverlap: false,
                            itemStyle: {
                                borderRadius: 10,
                                borderColor: '#1a2a6c',
                                borderWidth: 2,
                            },
                            label: {
                                show: false,
                                position: 'center',
                            },
                            emphasis: {
                                label: {
                                    show: true,
                                    fontSize: '16',
                                    fontWeight: 'bold',
                                    color: '#e2e8f0',
                                },
                            },
                            labelLine: {
                                show: false,
                            },
                            data: pieData,
                        },
                    ],
                };

                // Êö¥ÂáªÁéá/Âπ∏ËøêËß¶ÂèëÁéáÂØπÊØîÂõæ
                const critOption = {
                    title: {
                        text: `${typeLabel}Skill Critical Hit Rate and Luck Trigger Rate`,
                        left: 'center',
                        textStyle: { color: '#e2e8f0' },
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: { type: 'shadow' },
                        backgroundColor: 'rgba(40, 40, 60, 0.9)',
                        borderColor: '#3498db',
                        textStyle: { color: '#ecf0f1' },
                    },
                    legend: {
                        data: ['Critical Hit Rate', 'Lucky Hit Rate'],
                        bottom: 10,
                        textStyle: { color: '#cbd5e0' },
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '15%',
                        top: '15%',
                        containLabel: true,
                    },
                    xAxis: {
                        type: 'category',
                        data: skillNames.map((name) => `${name}`),
                        axisLine: { lineStyle: { color: '#7f8c8d' } },
                        axisLabel: {
                            color: '#95a5a6',
                            interval: 0,
                            rotate: 45,
                        },
                    },
                    yAxis: {
                        type: 'value',
                        name: 'Percentage',
                        min: 0,
                        max: 100,
                        axisLine: { lineStyle: { color: '#7f8c8d' } },
                        axisLabel: { color: '#95a5a6' },
                        splitLine: { lineStyle: { color: 'rgba(127, 140, 141, 0.2)' } },
                    },
                    series: [
                        {
                            name: 'Critical Hit Rate',
                            type: 'bar',
                            data: critRates,
                            itemStyle: { color: '#ff9966' },
                        },
                        {
                            name: 'Lucky Hit Rate',
                            type: 'bar',
                            data: luckyRates,
                            itemStyle: { color: '#93f9b9' },
                        },
                    ],
                };

                skillChart1.setOption(damageOption);
                skillChart2.setOption(critOption);
                ensureSkillChartsResizeListener();
            }

            // Ëé∑ÂèñÁî®Êà∑Êï∞ÊçÆÁöÑËæÖÂä©ÂáΩÊï∞
            function getUserFromArray(userId) {
                return currentUserArray.find((user) => user.id.toString() === userId.toString());
            }

            // Âà§Êñ≠ËßíËâ≤ÊòØÂê¶Êú™ÂèÇ‰∏éÊàòÊñó
            function isUserInactive(user) {
                // Ê£ÄÊü•ÊÄª‰º§ÂÆ≥„ÄÅÊÄªDPS„ÄÅÊÄªHPSÊòØÂê¶ÈÉΩ‰∏∫0
                const totalDamage = user.total_damage?.total || 0;
                const totalDps = user.total_dps || 0;
                const totalHps = user.total_hps || 0;

                // Ê£ÄÊü•Êö¥ÂáªÁéáÂíåÂπ∏ËøêÁéáÊòØÂê¶‰∏∫NaN
                const critRate = user.total_count?.critical / user.total_count?.total;
                const luckyRate = user.total_count?.lucky / user.total_count?.total;

                return (totalDamage === 0 && totalDps === 0 && totalHps === 0) || (isNaN(critRate) && isNaN(luckyRate));
            }

            // ÂàáÊç¢ÈöêËóèÊú™ÂèÇÊàòËßíËâ≤ÂäüËÉΩ
            function toggleHideInactiveUsers() {
                hideInactiveUsers = !hideInactiveUsers;
                const btn = document.getElementById('hideInactiveBtn');
                if (hideInactiveUsers) {
                    btn.classList.add('active');
                    btn.innerHTML = 'üëÄ Hidden and not participating in the battle';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = 'üëÄ Hide non-participants';
                }

                // ÈáçÊñ∞Â§ÑÁêÜÂΩìÂâçÊï∞ÊçÆ
                if (currentUserArray && currentUserArray.length > 0) {
                    sortUserArray(currentUserArray);
                    let visibleUserArray = currentUserArray;

                    // Â¶ÇÊûúÂêØÁî®‰∫ÜÈöêËóèÊú™ÂèÇÊàòËßíËâ≤ÔºåËøõ‰∏ÄÊ≠•ËøáÊª§
                    if (hideInactiveUsers) {
                        visibleUserArray = visibleUserArray.filter((user) => !isUserInactive(user));
                    }

                    lastVisiableUserArray = visibleUserArray;
                    updateTables(visibleUserArray);
                }
            }

            // Â§ÑÁêÜÊï∞ÊçÆÊõ¥Êñ∞ÔºàWebSocketÂíåAPIÈÄöÁî®Ôºâ
            function processDataUpdate(data, updateHistory = true) {
                try {
                    // Â∞ÜÊï∞ÊçÆËΩ¨Êç¢‰∏∫Êï∞ÁªÑ‰ª•‰æøÊéíÂ∫è
                    const userArray = Object.keys(data.user).map((id) => ({
                        id: Number(id),
                        ...data.user[id],
                    }));

                    // ÁºìÂ≠òÂΩìÂâçÁî®Êà∑Êï∞ÁªÑ
                    currentUserArray = userArray;

                    // Ê†πÊçÆÂΩìÂâçÊéíÂ∫èÊ®°ÂºèÊéíÂ∫è
                    sortUserArray(userArray);

                    let visibleUserArray = userArray;

                    // Â¶ÇÊûúÂêØÁî®‰∫ÜÈöêËóèÊú™ÂèÇÊàòËßíËâ≤ÔºåËøõ‰∏ÄÊ≠•ËøáÊª§
                    if (hideInactiveUsers) {
                        visibleUserArray = visibleUserArray.filter((user) => !isUserInactive(user));
                    }

                    lastVisiableUserArray = visibleUserArray;
                    updateTables(visibleUserArray);
                } catch (err) {
                    console.error('Handling data update failures:', err);
                }
            }

            // ÁîüÊàêË°®Ê†ºË°å
            function updateTables(visibleUserArray) {
                const damageTable = document.getElementById('damageTable').querySelector('tbody');
                //Ëé∑ÂèñdamageTableÈáåÁöÑÊâÄÊúâË°å
                let existingRows = damageTable.querySelectorAll('tr');
                if (existingRows.length > visibleUserArray.length) {
                    // ÁßªÈô§Â§ö‰ΩôÁöÑË°å
                    for (let i = existingRows.length - 1; i >= visibleUserArray.length; i--) {
                        damageTable.removeChild(existingRows[i]);
                    }
                }
                if (existingRows.length < visibleUserArray.length) {
                    // Ê∑ªÂä†Êñ∞Ë°å
                    for (let i = existingRows.length; i < visibleUserArray.length; i++) {
                        const row = document.createElement('tr');
                        damageTable.appendChild(row);
                    }
                }
                existingRows = damageTable.querySelectorAll('tr');

                for (let i = 0; i < visibleUserArray.length; i++) {
                    const user = visibleUserArray[i];
                    const crit_rate = user.total_count.critical / user.total_count.total;
                    const lucky_rate = user.total_count.lucky / user.total_count.total;

                    const row = existingRows[i];

                    const isSimpleMode = document.body.classList.contains('simple-mode');

                    // ÂÖ∂‰ªñÊï∞ÊçÆÂàó
                    const otherCells = [
                        user.profession || 'Unknown',
                        Number(user.fightPoint).toLocaleString(),
                        (user.hp ?? 'Unknown').toLocaleString(),
                        Number(user.taken_damage).toLocaleString(),
                        user.dead_count ?? 'Unknown',
                        `${(crit_rate * 100).toFixed(2)}%`,
                        `${(lucky_rate * 100).toFixed(2)}%`,
                    ];
                    if (currentDataGroup === 'damage' || currentDataGroup === 'all') {
                        otherCells.push(Number(user.total_damage.total).toLocaleString());
                        if (!isSimpleMode) {
                            otherCells.push(
                                Number(user.total_damage.critical).toLocaleString(),
                                Number(user.total_damage.lucky).toLocaleString(),
                                Number(user.total_damage.crit_lucky).toLocaleString(),
                            );
                        }
                        otherCells.push(
                            Number(user.realtime_dps).toLocaleString(),
                            Number(user.realtime_dps_max).toLocaleString(),
                            Number(user.total_dps.toFixed(2)).toLocaleString(),
                        );
                    }
                    if (currentDataGroup === 'healing' || currentDataGroup === 'all') {
                        otherCells.push(Number(user.total_healing.total).toLocaleString());
                        if (!isSimpleMode) {
                            otherCells.push(
                                Number(user.total_healing.critical).toLocaleString(),
                                Number(user.total_healing.lucky).toLocaleString(),
                                Number(user.total_healing.crit_lucky).toLocaleString(),
                            );
                        }
                        otherCells.push(
                            Number(user.realtime_hps).toLocaleString(),
                            Number(user.realtime_hps_max).toLocaleString(),
                            Number(user.total_hps.toFixed(2)).toLocaleString(),
                        );
                    }
                    let existingCells = row.querySelectorAll('td');
                    //ÊâÄÈúÄÂ±ïÁ§∫ÁöÑÂàóÊï∞
                    const requiredColumnCount = 3 + otherCells.length;
                    if (existingCells.length > requiredColumnCount) {
                        // ÁßªÈô§Â§ö‰ΩôÁöÑÂçïÂÖÉÊ†º
                        for (let j = existingCells.length - 1; j >= requiredColumnCount; j--) {
                            row.removeChild(existingCells[j]);
                        }
                    }
                    if (existingCells.length < requiredColumnCount) {
                        // Ê∑ªÂä†Êñ∞ÂçïÂÖÉÊ†º
                        for (let j = existingCells.length; j < requiredColumnCount; j++) {
                            const cell = document.createElement('td');
                            row.appendChild(cell);
                        }
                    }
                    existingCells = row.querySelectorAll('td');
                    // Êõ¥Êñ∞ÂçïÂÖÉÊ†ºÂÜÖÂÆπ
                    existingCells.forEach((cell, index) => {
                        if (index < 2) return;
                        if (otherCells[index - 2] !== undefined) {
                            cell.textContent = otherCells[index - 2];
                        }
                    });

                    // ËßíËâ≤IDÂàó
                    const uidCell = existingCells[0];
                    uidCell.textContent = `${user.id}`;

                    // ËßíËâ≤ÊòµÁß∞Âàó
                    const nicknameCell = existingCells[1];
                    // Check if user.name is a non-empty string
                    const hasValidName = user.name && user.name.trim() !== '';
                    const nickname = userNicknames[user.id] || (hasValidName ? user.name : '');

                    nicknameCell.textContent = nickname;
                    const operationCell = existingCells[existingCells.length - 1];
                    if (operationCell.querySelector('.skill-btn')) {
                        // Â¶ÇÊûúÂ∑≤ÁªèÂ≠òÂú®ÊäÄËÉΩÊåâÈíÆÔºåÂàôÂè™Êõ¥Êñ∞Áî®Êà∑ID
                        operationCell.querySelector('.skill-btn').setAttribute('data-user-id', user.id);
                        operationCell.querySelector('.copy-btn').setAttribute('data-user-id', user.id);
                    } else {
                        operationCell.innerHTML = '';
                        const operationDiv = document.createElement('div');
                        operationDiv.className = 'operation-div';
                        operationCell.appendChild(operationDiv);

                        // ÂàõÂª∫Â§çÂà∂ÊåâÈíÆ
                        const copyButton = document.createElement('button');
                        copyButton.className = 'copy-btn';
                        copyButton.innerHTML = '<i class="icon">üìã</i> Copy data';
                        copyButton.setAttribute('data-user-id', user.id);
                        operationDiv.appendChild(copyButton);

                        // ÂàõÂª∫ÊäÄËÉΩÊåâÈíÆ
                        const skillButton = document.createElement('button');
                        skillButton.className = 'skill-btn';
                        skillButton.innerHTML = '<i class="icon">üìä</i> Skill Analysis';
                        skillButton.setAttribute('data-user-id', user.id);
                        operationDiv.appendChild(skillButton);
                    }
                }
                updateTableStickyHeader();
                // Â∫îÁî®ÂàóÊòæÁ§∫ËÆæÁΩÆ
                if (typeof applyColumnVisibility === 'function') {
                    applyColumnVisibility();
                }
            }

            async function fetchData() {
                try {
                    if (historyTimeStamp === 0) throw new Error('invalid timestamp');
                    const res = await fetch(`/api/history/${historyTimeStamp}/data`);
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    const data = await res.json();
                    processDataUpdate(data);
                    document.querySelector('.no-data').style.display = 'none';
                } catch (err) {
                    console.error('Failed to retrieve data:', err);
                    document.querySelector('.no-data').style.display = 'block';
                }
            }

            async function fetchHistoryList() {
                try {
                    const res = await fetch(`/api/history/list`);
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    const data = await res.json();
                    for (const ts of data.data) {
                        availableTimeStamps.push(await fetchHistorySummary(ts));
                    }
                    const select = document.getElementById('chooseTime');
                    select.innerHTML = '';
                    const opt = document.createElement('option');
                    opt.value = 0;
                    opt.textContent = 'Please select a time to retrieve the data.';
                    select.appendChild(opt);
                    availableTimeStamps.forEach((item) => {
                        const opt = document.createElement('option');
                        opt.value = item.timestamp;
                        opt.textContent = item.name;
                        select.appendChild(opt);
                    });
                } catch (err) {
                    console.error('Failed to retrieve historical list:', err);
                }
            }

            async function fetchHistorySummary(timestamp) {
                try {
                    const res = await fetch(`/api/history/${timestamp}/summary`);
                    if (!res.ok) {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                    const data = await res.json();
                    console.log(data);
                    return {
                        timestamp: timestamp,
                        name: `${data.data.maxHpMonster || ''} ${data.data.userCount}‰∫∫ ${new Date(data.data.startTime).toLocaleString()} ‚û° ${new Date(data.data.endTime).toLocaleString()}`,
                    };
                } catch (err) {
                    console.error('Failed to retrieve historical list:', err);
                }
                return {
                    timestamp: timestamp,
                    name: new Date(Number(timestamp)).toLocaleString(),
                };
            }

            function sortUserArray(userArray) {
                switch (currentSortMode) {
                    case 'damage':
                        userArray.sort((a, b) => b.total_damage.total - a.total_damage.total);
                        break;
                    case 'uid':
                        userArray.sort((a, b) => a.id - b.id);
                        break;
                    case 'dps':
                        userArray.sort((a, b) => b.total_dps - a.total_dps);
                        break;
                    case 'realtimeDpsMax':
                        userArray.sort((a, b) => b.realtime_dps_max - a.realtime_dps_max);
                        break;
                    case 'takenDamage':
                        userArray.sort((a, b) => b.taken_damage - a.taken_damage);
                        break;
                    case 'healing':
                        userArray.sort((a, b) => b.total_healing.total - a.total_healing.total);
                        break;
                    case 'hps':
                        userArray.sort((a, b) => b.total_hps - a.total_hps);
                        break;
                    case 'realtimeHpsMax':
                        userArray.sort((a, b) => b.realtime_hps_max - a.realtime_hps_max);
                        break;
                    case 'fightPoint':
                        userArray.sort((a, b) => b.fightPoint - a.fightPoint);
                        break;
                    case 'hp_min':
                        userArray.sort((a, b) => a.hp - b.hp);
                        break;
                    default:
                        userArray.sort((a, b) => a.id - b.id);
                        break;
                }
            }

            function updateSortMode() {
                const select = document.getElementById('sortSelect');
                currentSortMode = select.value;
                fetchData();
            }

            function updateTimeStamp() {
                const select = document.getElementById('chooseTime');
                historyTimeStamp = Number(select.value);
                fetchData();
            }

            // È°µÈù¢Âä†ËΩΩÊó∂Ê£ÄÊü•Êú¨Âú∞Â≠òÂÇ®ÁöÑ‰∏ªÈ¢òÂÅèÂ•ΩÂíåÊéíÂ∫èÂÅèÂ•Ω
            function initTheme() {
                const isDarkMode = localStorage.getItem('darkMode') === 'true';
                const body = document.body;

                if (isDarkMode) {
                    body.classList.add('dark-mode');
                }
            }

            function initSortMode() {
                const savedSortMode = localStorage.getItem('sortMode');
                if (savedSortMode) {
                    currentSortMode = savedSortMode;
                    document.getElementById('sortSelect').value = savedSortMode;
                }
            }

            // ÂàùÂßãÂåñÊï∞ÊçÆÁªÑÊòæÁ§∫Ê®°Âºè
            function initDataGroup() {
                const savedDataGroup = localStorage.getItem('dataGroup') || 'damage';
                currentDataGroup = savedDataGroup;
                setDataGroup(savedDataGroup);
            }

            // ÂàáÊç¢Êï∞ÊçÆÁªÑÊòæÁ§∫
            function toggleDataGroup(group) {
                currentDataGroup = group;
                setDataGroup(group);
                updateTables(lastVisiableUserArray);
            }

            // ËÆæÁΩÆÊï∞ÊçÆÁªÑÊòæÁ§∫Áä∂ÊÄÅ
            function setDataGroup(group) {
                const body = document.body;
                const damageBtn = document.getElementById('damageGroupBtn');
                const healingBtn = document.getElementById('healingGroupBtn');
                const allBtn = document.getElementById('allGroupBtn');

                body.classList.remove('hide-damage', 'hide-healing');
                [damageBtn, healingBtn, allBtn].forEach((btn) => {
                    if (btn) btn.classList.remove('active');
                });

                switch (group) {
                    case 'damage':
                        body.classList.add('hide-healing');
                        if (damageBtn) damageBtn.classList.add('active');
                        break;
                    case 'healing':
                        body.classList.add('hide-damage');
                        if (healingBtn) healingBtn.classList.add('active');
                        break;
                    case 'all':
                        if (allBtn) allBtn.classList.add('active');
                        break;
                    default:
                        // ÈªòËÆ§ÊòæÁ§∫‰º§ÂÆ≥&DPS
                        body.classList.add('hide-healing');
                        if (damageBtn) damageBtn.classList.add('active');
                        break;
                }
            }

            // ÁÇπÂáªÂºπÁ™óÂ§ñÈÉ®Âå∫ÂüüÂÖ≥Èó≠ÂºπÁ™ó
            window.onclick = function (event) {
                const columnModal = document.getElementById('columnSettingsModal');
                const skillModal = document.getElementById('skillModal');
                if (event.target === columnModal) {
                    closeColumnSettings();
                } else if (event.target === skillModal) {
                    closeSkillModal();
                }
            };

            // ÂàóÊòæÁ§∫ËÆæÁΩÆÁõ∏ÂÖ≥ÂäüËÉΩ
            let columnVisibility = {
                uid: true,
                nickname: true,
                job: true,
                score: true,
                hp: true,
                takenDamage: true,
                deadCount: true,
                critRate: true,
                luckyRate: true,
                totalDamage: true,
                pureCrit: true,
                pureLucky: true,
                critLucky: true,
                realtimeDps: true,
                realtimeDpsMax: true,
                dps: true,
                totalHealing: true,
                healingPureCrit: true,
                healingPureLucky: true,
                healingCritLucky: true,
                realtimeHps: true,
                realtimeHpsMax: true,
                hps: true,
                actions: true,
            };

            // Êõ¥Êñ∞Â§çÈÄâÊ°ÜÁä∂ÊÄÅ
            function updateColumnCheckboxes() {
                Object.keys(columnVisibility).forEach((column) => {
                    const checkbox = document.querySelector(`#col-${column}`);
                    if (checkbox) {
                        checkbox.checked = columnVisibility[column];
                    }
                });
            }

            function downloadFightLog() {
                window.open(`/api/history/${historyTimeStamp}/download`);
            }

            // ÊâìÂºÄÂàóËÆæÁΩÆÂºπÁ™ó
            function openColumnSettings() {
                generateColumnSettingsContent();
                document.getElementById('columnSettingsModal').style.display = 'flex';
            }

            // ÂÖ≥Èó≠ÂàóËÆæÁΩÆÂºπÁ™ó
            function closeColumnSettings() {
                document.getElementById('columnSettingsModal').style.display = 'none';
            }

            // Âä®ÊÄÅÁîüÊàêÂàóËÆæÁΩÆÂÜÖÂÆπ
            function generateColumnSettingsContent() {
                const modal = document.getElementById('columnSettingsModal');
                const content = modal.querySelector('.column-settings-content');

                // Ê∏ÖÈô§Áé∞ÊúâÂÜÖÂÆπÔºà‰øùÁïôÊ†áÈ¢òÔºâ
                const existingGroups = content.querySelectorAll('.column-group');
                existingGroups.forEach((group) => group.remove());

                const isSimpleMode = document.body.classList.contains('simple-mode');

                // Âü∫Á°Ä‰ø°ÊÅØÁªÑ
                const baseGroup = createColumnGroup('üî∞ Basic Information', [
                    { id: 'uid', label: 'Character ID', column: 'uid' },
                    { id: 'nickname', label: 'Character Nickname', column: 'nickname' },
                    { id: 'job', label: 'Occupation', column: 'job' },
                    { id: 'score', label: 'Rating', column: 'score' },
                    { id: 'hp', label: 'HP', column: 'hp' },
                    { id: 'takenDamage', label: 'Damage Taken', column: 'takenDamage' },
                    { id: 'deadCount', label: 'Deaths', column: 'deadCount' },
                    { id: 'critRate', label: 'Critical Hit Rate', column: 'critRate' },
                    { id: 'luckyRate', label: 'Lucky Hit Rate', column: 'luckyRate' },
                ]);
                content.appendChild(baseGroup);

                // Ê†πÊçÆÂΩìÂâçÊï∞ÊçÆÁªÑÊòæÁ§∫Áõ∏Â∫îÁöÑÂàóËÆæÁΩÆ
                if (currentDataGroup === 'damage' || currentDataGroup === 'all') {
                    // ‰º§ÂÆ≥Êï∞ÊçÆÁªÑ
                    const damageOptions = [{ id: 'totalDamage', label: 'Total Damage', column: 'totalDamage' }];

                    if (!isSimpleMode) {
                        damageOptions.push(
                            { id: 'pureCrit', label: 'True Critical Hit', column: 'pureCrit' },
                            { id: 'pureLucky', label: 'True Lucky Hit', column: 'pureLucky' },
                            { id: 'critLucky', label: 'Critical Hit Luck', column: 'critLucky' },
                        );
                    }

                    const damageGroup = createColumnGroup('‚öîÔ∏è Damage Data', damageOptions);
                    content.appendChild(damageGroup);

                    // DPSÊï∞ÊçÆÁªÑ
                    const dpsGroup = createColumnGroup('‚ö° DPS Data', [
                        { id: 'realtimeDps', label: 'Instantaneous DPS', column: 'realtimeDps' },
                        { id: 'realtimeDpsMax', label: 'Maximum instantaneous', column: 'realtimeDpsMax' },
                        { id: 'dps', label: 'Total DPS', column: 'dps' },
                    ]);
                    content.appendChild(dpsGroup);
                }

                if (currentDataGroup === 'healing' || currentDataGroup === 'all') {
                    // Ê≤ªÁñóÊï∞ÊçÆÁªÑ
                    const healingOptions = [{ id: 'totalHealing', label: 'Overall Healing', column: 'totalHealing' }];

                    if (!isSimpleMode) {
                        healingOptions.push(
                            { id: 'healingPureCrit', label: 'True Critical Hit', column: 'healingPureCrit' },
                            { id: 'healingPureLucky', label: 'True Lucky Hit', column: 'healingPureLucky' },
                            { id: 'healingCritLucky', label: 'Critical Hit Luck', column: 'healingCritLucky' },
                        );
                    }

                    const healingGroup = createColumnGroup('‚ù§Ô∏è Healing Data', healingOptions);
                    content.appendChild(healingGroup);

                    // HPSÊï∞ÊçÆÁªÑ
                    const hpsGroup = createColumnGroup('üíö HPS Data', [
                        { id: 'realtimeHps', label: 'Instantaneous HPS', column: 'realtimeHps' },
                        { id: 'realtimeHpsMax', label: 'Maximum instantaneous', column: 'realtimeHpsMax' },
                        { id: 'hps', label: 'Total HPS', column: 'hps' },
                    ]);
                    content.appendChild(hpsGroup);
                }

                // ÂÖ∂‰ªñÁªÑ
                const otherGroup = createColumnGroup('üîß Others', [{ id: 'actions', label: 'Operation', column: 'actions' }]);
                content.appendChild(otherGroup);

                // ÈáçÊñ∞ÁªëÂÆö‰∫ã‰ª∂
                initColumnSettings();
            }

            // ÂàõÂª∫ÂàóËÆæÁΩÆÁªÑ
            function createColumnGroup(title, options) {
                const group = document.createElement('div');
                group.className = 'column-group';

                const groupTitle = document.createElement('div');
                groupTitle.className = 'column-group-title';
                groupTitle.textContent = title;
                group.appendChild(groupTitle);

                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'column-options';

                options.forEach((option) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'column-option';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `col-${option.id}`;
                    checkbox.setAttribute('data-column', option.column);
                    checkbox.checked = columnVisibility[option.column] || false;

                    const label = document.createElement('label');
                    label.setAttribute('for', `col-${option.id}`);
                    label.textContent = option.label;

                    optionDiv.appendChild(checkbox);
                    optionDiv.appendChild(label);
                    optionsContainer.appendChild(optionDiv);
                });

                group.appendChild(optionsContainer);
                return group;
            }

            // Â∫îÁî®ÂàóÊòæÁ§∫ËÆæÁΩÆ
            function applyColumnVisibility() {
                const table = document.getElementById('damageTable');
                if (!table) return;

                // Âü∫Á°Ä‰ø°ÊÅØÂàóÔºàrowspan=2Ôºâ
                const baseColumns = [
                    { column: 'uid', selector: 'th[title="Unique Role Identifier"]' },
                    { column: 'nickname', selector: 'th[title="Character Nickname/Custom Nickname"]' },
                    { column: 'job', selector: 'th[title="Character Class"]' },
                    { column: 'score', selector: 'th[title="Character Rating"]' },
                    { column: 'hp', selector: 'th[title="Character Health Points"]' },
                    { column: 'takenDamage', selector: 'th[title="Damage taken by the character during combat"]' },
                    { column: 'deadCount', selector: 'th[title="Number of times the character died in combat"]' },
                    { column: 'critRate', selector: 'th[title="The proportion of critical hits to total hits dealt by a character during combat"]' },
                    { column: 'luckyRate', selector: 'th[title="The proportion of critical hits to total hits during combat"]' },
                ];

                // Â∫îÁî®Âü∫Á°ÄÂàóÁöÑÊòæÁ§∫/ÈöêËóè
                baseColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // ‰º§ÂÆ≥Áõ∏ÂÖ≥Âàó
                const damageColumns = [
                    { column: 'totalDamage', selector: 'th[title="Total damage dealt by the character during combat"]' },
                    { column: 'pureCrit', selector: 'th[title="Non-critical hit damage dealt by the character during combat"]' },
                    { column: 'pureLucky', selector: 'th[title="Non-critical luck damage dealt by the character during combat"]' },
                    { column: 'critLucky', selector: 'th[title="Critical hit damage dealt by the character during combat"]' },
                ];

                damageColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // DPSÁõ∏ÂÖ≥Âàó
                const dpsColumns = [
                    { column: 'realtimeDps', selector: 'th[title="Damage dealt by the character in the last second of combat"]' },
                    { column: 'realtimeDpsMax', selector: 'th[title="Maximum instantaneous DPS of a character during combat"]' },
                    { column: 'dps', selector: 'th[title="Total DPS of a character during combat (calculated using the time between the first and last skill as effective combat duration)"]' },
                ];

                dpsColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // Ê≤ªÁñóÁõ∏ÂÖ≥Âàó
                const healingColumns = [
                    { column: 'totalHealing', selector: 'th[title="Total healing provided by the character during combat"]' },
                    { column: 'healingPureCrit', selector: 'th[title="Non-critical hit healing dealt by the character during combat"]' },
                    { column: 'healingPureLucky', selector: 'th[title="Non-critical luck-based healing dealt by the character during combat"]' },
                    { column: 'healingCritLucky', selector: 'th[title="Critical hit healing amount inflicted by the character during combat"]' },
                ];

                healingColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // HPSÁõ∏ÂÖ≥Âàó
                const hpsColumns = [
                    { column: 'realtimeHps', selector: 'th[title="Damage and healing dealt by the character in the last second of combat"]' },
                    { column: 'realtimeHpsMax', selector: 'th[title="Character\'s maximum instantaneous HPS during combat"]' },
                    { column: 'hps', selector: 'th[title="Total HPS per character during combat (calculated using the time between the first and last skills as effective combat duration)"]' },
                ];

                hpsColumns.forEach(({ column, selector }) => {
                    const isVisible = columnVisibility[column];
                    const headerCell = table.querySelector(selector);
                    if (headerCell) {
                        if (isVisible) {
                            headerCell.style.removeProperty('display');
                        } else {
                            headerCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });

                // Êìç‰ΩúÂàó
                const actionsHeader = table.querySelector('th:last-child');
                if (actionsHeader && actionsHeader.textContent.includes('Operation')) {
                    if (columnVisibility.actions) {
                        actionsHeader.style.removeProperty('display');
                    } else {
                        actionsHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                // Â∫îÁî®Ë°®‰ΩìÂçïÂÖÉÊ†ºÁöÑÊòæÁ§∫/ÈöêËóè
                applyBodyColumnVisibility();

                // Êõ¥Êñ∞colspan
                updateColspan();
            }

            // Â∫îÁî®Ë°®‰ΩìÂçïÂÖÉÊ†ºÁöÑÊòæÁ§∫/ÈöêËóè
            function applyBodyColumnVisibility() {
                const table = document.getElementById('damageTable');
                if (!table) return;

                // Ëé∑ÂèñÊâÄÊúâË°®‰ΩìË°å
                const rows = table.querySelectorAll('tbody tr');

                rows.forEach((row) => {
                    const cells = row.querySelectorAll('td');

                    // Âü∫Á°Ä‰ø°ÊÅØÂàó (0-8)
                    const baseCols = ['uid', 'nickname', 'job', 'score', 'hp', 'takenDamage', 'deadCount', 'critRate', 'luckyRate'];
                    baseCols.forEach((col, index) => {
                        if (cells[index]) {
                            if (columnVisibility[col]) {
                                cells[index].style.removeProperty('display');
                            } else {
                                cells[index].style.setProperty('display', 'none', 'important');
                            }
                        }
                    });

                    // Âä®ÊÄÅÂàóÈúÄË¶ÅÊ†πÊçÆÂΩìÂâçÊï∞ÊçÆÁªÑÂíåÁÆÄÊ¥ÅÊ®°ÂºèÊù•Á°ÆÂÆö‰ΩçÁΩÆ
                    let cellIndex = 9; // ‰ªéÁ¨¨10ÂàóÂºÄÂßã

                    // Â§ÑÁêÜ‰º§ÂÆ≥Áõ∏ÂÖ≥Âàó
                    if (currentDataGroup === 'damage' || currentDataGroup === 'all') {
                        // ÊÄª‰º§ÂÆ≥Âàó
                        if (cells[cellIndex]) {
                            if (columnVisibility.totalDamage) {
                                cells[cellIndex].style.removeProperty('display');
                            } else {
                                cells[cellIndex].style.setProperty('display', 'none', 'important');
                            }
                        }
                        cellIndex++;

                        // ËØ¶ÁªÜ‰º§ÂÆ≥ÂàóÔºàÈùûÁÆÄÊ¥ÅÊ®°ÂºèÔºâ
                        if (!document.body.classList.contains('simple-mode')) {
                            const detailCols = ['pureCrit', 'pureLucky', 'critLucky'];
                            detailCols.forEach((col) => {
                                if (cells[cellIndex]) {
                                    if (columnVisibility[col]) {
                                        cells[cellIndex].style.removeProperty('display');
                                    } else {
                                        cells[cellIndex].style.setProperty('display', 'none', 'important');
                                    }
                                }
                                cellIndex++;
                            });
                        }

                        // DPSÂàó
                        const dpsCols = ['realtimeDps', 'realtimeDpsMax', 'dps'];
                        dpsCols.forEach((col) => {
                            if (cells[cellIndex]) {
                                if (columnVisibility[col]) {
                                    cells[cellIndex].style.removeProperty('display');
                                } else {
                                    cells[cellIndex].style.setProperty('display', 'none', 'important');
                                }
                            }
                            cellIndex++;
                        });
                    }

                    // Â§ÑÁêÜÊ≤ªÁñóÁõ∏ÂÖ≥Âàó
                    if (currentDataGroup === 'healing' || currentDataGroup === 'all') {
                        // ÊÄªÊ≤ªÁñóÂàó
                        if (cells[cellIndex]) {
                            if (columnVisibility.totalHealing) {
                                cells[cellIndex].style.removeProperty('display');
                            } else {
                                cells[cellIndex].style.setProperty('display', 'none', 'important');
                            }
                        }
                        cellIndex++;

                        // ËØ¶ÁªÜÊ≤ªÁñóÂàóÔºàÈùûÁÆÄÊ¥ÅÊ®°ÂºèÔºâ
                        if (!document.body.classList.contains('simple-mode')) {
                            const healingDetailCols = ['healingPureCrit', 'healingPureLucky', 'healingCritLucky'];
                            healingDetailCols.forEach((col) => {
                                if (cells[cellIndex]) {
                                    if (columnVisibility[col]) {
                                        cells[cellIndex].style.removeProperty('display');
                                    } else {
                                        cells[cellIndex].style.setProperty('display', 'none', 'important');
                                    }
                                }
                                cellIndex++;
                            });
                        }

                        // HPSÂàó
                        const hpsCols = ['realtimeHps', 'realtimeHpsMax', 'hps'];
                        hpsCols.forEach((col) => {
                            if (cells[cellIndex]) {
                                if (columnVisibility[col]) {
                                    cells[cellIndex].style.removeProperty('display');
                                } else {
                                    cells[cellIndex].style.setProperty('display', 'none', 'important');
                                }
                            }
                            cellIndex++;
                        });
                    }

                    // Êìç‰ΩúÂàóÔºàÊúÄÂêé‰∏ÄÂàóÔºâ
                    const lastCell = cells[cells.length - 1];
                    if (lastCell) {
                        if (columnVisibility.actions) {
                            lastCell.style.removeProperty('display');
                        } else {
                            lastCell.style.setProperty('display', 'none', 'important');
                        }
                    }
                });
            }

            // Êõ¥Êñ∞Ë°®Â§¥ÁöÑcolspan
            function updateColspan() {
                const table = document.getElementById('damageTable');
                if (!table) return;

                // ËÆ°ÁÆóÂêÑÁªÑÂèØËßÅÂàóÊï∞
                const damageMainVisible = ['totalDamage', 'pureCrit', 'pureLucky', 'critLucky'].filter((col) => columnVisibility[col]).length;
                const dpsVisible = ['realtimeDps', 'realtimeDpsMax', 'dps'].filter((col) => columnVisibility[col]).length;
                const healingMainVisible = ['totalHealing', 'healingPureCrit', 'healingPureLucky', 'healingCritLucky'].filter(
                    (col) => columnVisibility[col],
                ).length;
                const hpsVisible = ['realtimeHps', 'realtimeHpsMax', 'hps'].filter((col) => columnVisibility[col]).length;

                // Êõ¥Êñ∞colspan
                const damageMainHeader = table.querySelector('.damage-main-col');
                const dpsHeader = table.querySelector('.dps-col');
                const healingMainHeader = table.querySelector('.healing-main-col');
                const hpsHeader = table.querySelector('.hps-col');

                if (damageMainHeader) {
                    if (damageMainVisible > 0) {
                        damageMainHeader.setAttribute('colspan', damageMainVisible);
                        damageMainHeader.style.removeProperty('display');
                    } else {
                        damageMainHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                if (dpsHeader) {
                    if (dpsVisible > 0) {
                        dpsHeader.setAttribute('colspan', dpsVisible);
                        dpsHeader.style.removeProperty('display');
                    } else {
                        dpsHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                if (healingMainHeader) {
                    if (healingMainVisible > 0) {
                        healingMainHeader.setAttribute('colspan', healingMainVisible);
                        healingMainHeader.style.removeProperty('display');
                    } else {
                        healingMainHeader.style.setProperty('display', 'none', 'important');
                    }
                }

                if (hpsHeader) {
                    if (hpsVisible > 0) {
                        hpsHeader.setAttribute('colspan', hpsVisible);
                        hpsHeader.style.removeProperty('display');
                    } else {
                        hpsHeader.style.setProperty('display', 'none', 'important');
                    }
                }
            }

            // ÂàóËÆæÁΩÆÂ§çÈÄâÊ°ÜÂèòÂåñ‰∫ã‰ª∂
            function initColumnSettings() {
                document.querySelectorAll('#columnSettingsModal input[type="checkbox"]').forEach((checkbox) => {
                    checkbox.addEventListener('change', function () {
                        const column = this.getAttribute('data-column');
                        columnVisibility[column] = this.checked;
                        applyColumnVisibility();
                    });
                });
            }

            // ÂàùÂßãÂåñÂàóËÆæÁΩÆ
            document.addEventListener('DOMContentLoaded', function () {
                initColumnSettings();
            });

            // ÈîÆÁõòESCÈîÆÂÖ≥Èó≠ÂºπÁ™ó
            document.addEventListener('keydown', function (event) {
                if (event.key === 'Escape') {
                    const skillModal = document.getElementById('skillModal');

                    if (skillModal.style.display === 'block') {
                        closeSkillModal();
                    }
                }
            });

            // ÂàùÂßãÂåñ
            function initialize() {
                initTheme();
                initSortMode();
                initDataGroup();

                fetchHistoryList();
                fetchData();

                // Ê∑ªÂä†‰∫ã‰ª∂ÂßîÊâòÂ§ÑÁêÜÊäÄËÉΩÊåâÈíÆÁÇπÂáª
                const damageTable = document.getElementById('damageTable');
                if (damageTable) {
                    damageTable.addEventListener('click', function (event) {
                        // Â§ÑÁêÜÊäÄËÉΩÊåâÈíÆÁÇπÂáª
                        if (event.target.classList.contains('skill-btn') || event.target.closest('.skill-btn')) {
                            const button = event.target.classList.contains('skill-btn') ? event.target : event.target.closest('.skill-btn');
                            const userId = button.getAttribute('data-user-id');
                            if (userId) {
                                showSkillAnalysis(parseInt(userId));
                            }
                        }
                        // Â§ÑÁêÜÂ§çÂà∂ÊåâÈíÆÁÇπÂáª
                        else if (event.target.classList.contains('copy-btn') || event.target.closest('.copy-btn')) {
                            const button = event.target.classList.contains('copy-btn') ? event.target : event.target.closest('.copy-btn');
                            const userId = button.getAttribute('data-user-id');
                            if (userId) {
                                copyUserData(parseInt(userId));
                            }
                        }
                    });
                }
            }

            // Á≠âÂæÖDOMÂä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }
        </script>
        <script>
            function updateTableStickyHeader() {
                const damageTable = document.getElementById('damageTable');
                const damageTableRows = damageTable.querySelectorAll('tr');
                damageTableRows.forEach((row) => {
                    const top = row.offsetTop;
                    row.style.setProperty('--th-top', `${top}px`);
                });
            }
            window.addEventListener('resize', updateTableStickyHeader);
            document.addEventListener('DOMContentLoaded', updateTableStickyHeader);
        </script>

        <!-- ÂàóËÆæÁΩÆÂºπÁ™ó -->
        <div id="columnSettingsModal" class="column-settings-modal">
            <div class="column-settings-content">
                <div class="column-settings-header">
                    <div class="column-settings-title">‚öôÔ∏è Table Settings</div>
                    <button class="close-btn" onclick="closeColumnSettings()">&times;</button>
                </div>

                <!-- ÂÜÖÂÆπÂ∞ÜÈÄöËøá JavaScript Âä®ÊÄÅÁîüÊàê -->
            </div>
        </div>
    </body>
</html>
